var documenterSearchIndex = {"docs":
[{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"theory/#Equations","page":"Theory","title":"Equations","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"We solve the linearized Navier-Stokes equation in the anelastic approximation in a tracking frame that rotates at Omega_0 hatz. We represent the unperturbed zero-order profiles of background density by barrho, pressure by barp, temperature by barT, gravity by mathbfg and entropy by S_0. We denote perturbatations to these quantities using primes as superscripts. We define the velocity mathbfu=mathbfu_f + mathbfu_Omega, where mathbfu_f is the velocity associated with the waves, and mathbfu_Omega is that for the differentially rotating background. We also represent the perturbation in the background entropy by S^prime.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"This leads to the following equations:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginalign*\nnablacdotmathbfu_f=0\npartial_tmathbfu_f=mathbfutimesboldsymbolnablatimesmathbfu-2boldsymbolOmegatimesmathbfu_f-boldsymbolnablaleft(fracp^primebarrho+frac12mathbfu^2right)-fracS^primec_pmathbfg+frac1barrhomathbfF_nu\npartial_tS^prime=-imDeltaOmega S^prime-left(mathbfu_fcdotboldsymbolnablaright)S_0+kappafrac1barrhobarTboldsymbolnablacdotleft(barrhobarTboldsymbolnabla S^primeright)\nendalign*","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Here, c_p is the specific heat at constant pressure, and mathbfF_nu is the viscous force.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"We may expand the velocity in terms of stream functions as","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginalign*\nbarrhomathbfu_f = boldsymbolnablatimesboldsymbolnablatimesleft(barrhoWleft(mathbfxright)hatrright)+boldsymbolnablatimesleft(barrhoVleft(mathbfxright)hatrright)\nendalign*","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"This form of the velocity automatically satisfies the mass-conservation constraint. We expand the individual stream functions in a Chebyshev-spherical harmonic basis as","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginalign*Vleft(mathbfxright)  =sum_nell mV_nell mT_nleft(hatrright)hatP_ell mleft(costhetaright)expleft(imphiright)\nWleft(mathbfxright)  =sum_nell mW_nell mT_nleft(hatrright)hatP_ell mleft(costhetaright)expleft(imphiright)\nS^primeleft(mathbfxright)  =sum_nell mS_nell m^primeT_nleft(hatrright)hatP_ell mleft(costhetaright)expleft(imphiright)\nendalign*","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where hatr is a scaled radial coordinate that maps the radial domain to -11, and hatP_ell mleft(costhetaright) represents the normalized associated Legendre polynomial of degree ell and azimuthal order m. We note that owing to azimuthal symmetry of the background, the equations decouple in the azimuthal order m, and may be solved independently for each m. We may collectively express the coefficients V_nell m for a given m as boldsymbolV_m, and similarly for the other fields. In the following section, we suppress the subscript m for brevity.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Substituting, and transforming to temporal frequency space, we may rewrite the equations in the form","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"left(beginarrayccc\nA_VV  A_VW  A_VS\nA_WV  A_WW  A_WS\nA_SV  A_SW  A_SS\nendarrayright)\nleft(beginarrayc\nboldsymbolV\nboldsymbolW\nboldsymbolS\nendarrayright)=\nfracomegaOmega_0\nleft(beginarrayccc\nB_VV  0  0\n0  B_WW  0\n0  0  B_SS\nendarrayright)\nleft(beginarrayc\nboldsymbolV\nboldsymbolW\nboldsymbolS\nendarrayright)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where each matrix element represents an operator — potentially a differential one. We may express this in a condensed form as","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"A mathbfv = fracomegaOmega_0 B mathbfv","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where mathbfv now collects all the coefficients, and represents the eigenfunction that we want to solve for.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"We impose the boundary conditions","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":" u_r = partial_rleft(fracu_thetarright)=partial_rleft(fracu_phirright)=partial_r S^prime=0quadtextonr=r_iquadtextandr=r_o","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and use the standard spherical-harmonic boundary conditions at the poles. These conditions may be translated to the spectral coefficients to obtain sets of equations of the form","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"left(beginarrayccc\nC_VV  0  0\n0  C_WW  0\n0  0  C_SS\nendarrayright)left(beginarrayc\nboldsymbolV\nboldsymbolW\nboldsymbolS\nendarrayright)\t=left(beginarrayc\nboldsymbol0\nboldsymbol0\nboldsymbol0\nendarrayright)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"We may express this in a condensed form as","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"C mathbfv = 0","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"This tells us that the eigenfunction mathbfv lies in the null-space of C. We transform from the radial Chebyshev basis to a different one that satisfies the radial boundary conditions. If we collect the basis elements as the columns of a matrix Z, we obtain CZ=0 by construction. We may therefore express the eigenfunction as","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"mathbfv = Z mathbfw","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Substituting this into the eigenvalue problem, and multiplying both sides by Z^T, we obtain","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"left(Z^T A Zright) mathbfw = fracomegaOmega_0 left(Z^T B Zright) mathbfw","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"which is now unconstrained in mathbfw. We solve the eigenvalue problem to obtain solutions (omega mathbfw), and subsequently project the eigenfunctions back to the Chebyshev basis to obtain (omega mathbfv=Zmathbfw).","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"We note that solutions to A mathbfv = (omegaOmega_0) B mathbfv must necessarily satisfy left(Z^T A Zright) mathbfw = (omegaOmega_0) left(Z^T B Zright) mathbfw, but the projected problem may produce solutions that do not satisfy the original system. We therefore include a post-processing step to filter out such solutions. We also filter out solutions that are not smooth, as well as exponentially growing ones.","category":"page"},{"location":"theory/#Reference","page":"Theory","title":"Reference","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Bhattacharya, J., & Hanasoge, S. M. 2023, ApJS, 264, 21, doi: 10.3847/1538-4365/aca09a. Preprint available at the Arxiv link","category":"page"},{"location":"#RossbyWaveSpectrum.jl","page":"Using the code","title":"RossbyWaveSpectrum.jl","text":"","category":"section"},{"location":"","page":"Using the code","title":"Using the code","text":"A Julia code to compute the spectrum of inertial waves in the Sun.","category":"page"},{"location":"#Installation","page":"Using the code","title":"Installation","text":"","category":"section"},{"location":"","page":"Using the code","title":"Using the code","text":"To install the code, run ./INSTALL.sh. This requires bash and curl to run, and will download and install julia using the installer juliaup. It will also install the requisite project dependencies. The project uses Julia v1.10.0, which may be installed independently as well, in which case one only needs to instantiate the environments as listed in INSTALL.sh.","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"A part of installation process requires matplotlib to be available. If one is using an anaconda distribution located in their user directory, they may need to export PYTHON=<path to python> before running INSTALL.sh. So, for example, one may run","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"PYTHON=$HOME/anaconda3/bin/python ./INSTALL.sh","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"the first time the code is being installed (subsequent reinstallations will reuse the path that has been set). However, the code may be run without matplotlib as well, as it is only required for plotting the results.","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"Users running the code on a heterogeneous cluster (where the login and compute nodes have different CPU architectures) may want to set the environment variable JULIA_CPU_TARGET appropriately in their shell rc file. One may check the CPU architecture by running","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"julia> Sys.CPU_NAME\n\"skylake-avx512\"","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"in the julia REPL on each node.","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"As an example, a valid setting may be","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"export JULIA_CPU_TARGET=\"generic;skylake-avx512,clone_all;icelake-server,clone_all\"","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"if e.g. the login node has skylake-avx512 and the compute node has icelake-server. Setting this is particularly important if one node has Intel processors whereas the other has AMD ones. This should be set before running INSTALL.sh.","category":"page"},{"location":"#Starting-Julia","page":"Using the code","title":"Starting Julia","text":"","category":"section"},{"location":"","page":"Using the code","title":"Using the code","text":"Typically the code is run multi-threaded, so one needs to specify the number of threads while launching Julia. As an example, if we want to use 5 Julia threads, this may be done as","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"julia +1.10.0 --project=. --startup-file=no -t 5","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"The flag --project should point to the path to the code. The example above assumes that you are in the top-level code directory (RossbyWaveSpectrum.jl).","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"The flag --startup-file=no is optional, and may only be necessary if one has added a custom startup file that may interfere with the code.","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"The flag -t 5 indicates that 5 Julia threads are to be used. Typically, we would want to use as many Julia threads as the number of azimuthal orders m that we want to solve for. This ensures that all ms run in parallel. Note that this differs from the number of BLAS threads that are used in solving the eigenvalue problem. If the code is being run on a cluster, this is automatically inferred from the number of allocated cores and the number of Julia threads. Alternately, this may be specified through the environment variable MKL_NUM_THREADS.","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"note: Note\nCurrently, the code uses multi-threading and does not support distributed usage. Therefore one instance of the code must be launched on one node of a cluster. Distinct instances of the code that use different parameters may be run parallely on multiple nodes.","category":"page"},{"location":"#Running-the-code","page":"Using the code","title":"Running the code","text":"","category":"section"},{"location":"","page":"Using the code","title":"Using the code","text":"Before running the code, we would want to set the location where the output will be written to. This is determined by the environment variable SCRATCH, which typically corresponds to a user's scratch directory on a cluster. The output files will be written to $SCRATCH/RossbyWaves, and the path will be created if it doesn't exist. Note that if SCRATCH is not specified, it will be set to homedir() by default in the code.","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"The first step is to load the package","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"using RossbyWaveSpectrum","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"We start by computing the radial operators. We define some parameters:","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"nr, nℓ = 40, 20 # number of radial and latitudinal spectral coefficients\nr_in_frac = 0.65 # inner boundary of the domain as a fraction of the solar radius\nr_out_frac = 0.985 # outer boundary of the domain as a fraction of the solar radius\nν = 5e11 # kinematic viscosity coefficient in CGS units\ntrackingrate = :hanson2020 # track at 453.1 nHz; may also be a number in nHz","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"and compute the radial operators as","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"operators = radial_operators(nr, nℓ; r_in_frac, r_out_frac, ν, trackingrate)","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"Some of the common keyword arguments are demonstrated here. There are various other keyword arguments which may be passed to specify domain and model details. See radial_operators for details.","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"The second step is to obtain a function that will be used to compute the spectrum. We need to specify whether we seek equatorially symmetric or antisymmetric solutions, and the model of differential rotation that is used (see RossbyWaveSpectrum.solar_differential_rotation_profile_derivatives_grid for details). We define some parameters","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"V_symmetric = true # indicates that V is symmetric about the equator, alternately set to `false` for antisymmetric\nrotation_profile = :solar_latrad_squished # model of differential rotation to be used in the calculation","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"and compute the spectrum function as","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"spectrumfn! = RotMatrix(Val(:spectrum), V_symmetric, rotation_profile; operators)","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"Finally, we compute and save the spectrum for a range of azimuthal orders using the pre-defined parameters. We define","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"mrange = 2:6 # the range of azimuthal orders for which to compute the spectra","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"and compute the spctrum using","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"save_eigenvalues(spectrumfn!, mrange; operators)","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"This will save the results to a file named \"solar_latrad_squished_nr40_nl20_sym.jld2\" in the output directory given by RossbyWaveSpectrum.DATADIR[]. We may also specify filtering parameters as keyword arguments to save_eigenvalues, which will be passed on to filter_eigenvalues. The filtering may be performed later as well, as a post-processing step.","category":"page"},{"location":"#Loading-the-results","page":"Using the code","title":"Loading the results","text":"","category":"section"},{"location":"","page":"Using the code","title":"Using the code","text":"The results are stored in jld2 files that are read in using the package JLD2.jl. We provide an interface to read these in:","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"julia> Feig = FilteredEigen(datadir(\"solar_latrad_squished_nr40_nl20_sym.jld2\"))\nFiltered eigen with m range = 2:6","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"This will load the solutions for all m into a struct that may be passed directly to the plotting functions. To obtain the solutions for one m, we may index into Feig with that m:","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"julia> Feig[2]\nFiltered eigen with m = 2","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"The eigenvalues and eigenvectors for this m may be obtained as","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"julia> λs, vs = Feig[2];\n\njulia> λs\n4-element Vector{ComplexF64}:\n 0.4981592422711335 + 0.014103483029526536im\n 0.6967785422145395 + 0.00046298002829591573im\n  1.469490820471635 + 0.06912096500018029im\n 1.6005757491199637 + 0.03673314713783im","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"In the sign convention chosen in the code, a positive imaginary part of the eigenfrequencies indicates that the solutions are damped, and a positive real part indicates retrograde solutions. These are corrected for when plotting the solutions, so that the real part of the frequencies appear in the bottom right quadrant.","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"The operators and the parameters that were used to generate the solutions are saved in the FilteredEigen struct. The former is directly stored as Feig.operators, whereas the latter are stored in the field kw.","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"julia> Feig.kw\nDict{Symbol, Any} with 3 entries:\n  :V_symmetric      => true\n  :filterflags      => NODES|SPATIAL_RADIAL|SPATIAL_EQUATOR|BC|EIGVEC|EIGVAL|EIGEN\n  :rotation_profile => :solar_latrad_squished","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"warn: Warn\nThe file format and types of contents may not be identical across releases, and backward compatibility is not always guaranteed. Please use the same version of the package that was used to create the file to read it back in.","category":"page"},{"location":"#Filtering-the-solutions-further","page":"Using the code","title":"Filtering the solutions further","text":"","category":"section"},{"location":"","page":"Using the code","title":"Using the code","text":"Occasionally, it might be necessary to filter the solution set further to reduce the number of modes retained in the spectrum. This may be done through the function filter_eigenvalues. As an example,","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"julia> Feig_filt = filter_eigenvalues(Feig, filterflags = Filters.SPATIAL, n_cutoff = 5);","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"For a full list of flags that may be passed to filterflags, check Filters. For the filter parameters that may be passed as keyword arguments, check the keys of RossbyWaveSpectrum.DefaultFilterParams. This also lists the default values that are used when computing the solutions.","category":"page"},{"location":"#Plotting-the-results","page":"Using the code","title":"Plotting the results","text":"","category":"section"},{"location":"","page":"Using the code","title":"Using the code","text":"The plotting functions are provided by the module RossbyPlots. This resides in a separate environment, which must be activated first using","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"julia> import Pkg\n\njulia> Pkg.pkg\"activate RossbyPlots\"","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"Alternately, one may press the ] key from the julia REPL to enter the interactive Pkg mode, and execute","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"(RossbyWaveSpectrum) pkg> activate RossbyPlots\n  Activating project at [...]\n\n(RossbyPlots) pkg>","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"and finally press the backspace key to get back to the REPL prompt.","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"The plotting functions use matplotlib, which must be available on the system, and accessible to PyPlot. The plots shown here were generated using matplotlib version 3.4.3. See the installation section on instructions to set this up if necessary.","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"We may plot the spectrum as","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"julia> using RossbyPlots\n\njulia> spectrum(Feig_filt)","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"This will produce the following plot:","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"(Image: spectrum)","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"We find several ridges of eigenvalues.","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"note: Note\nBy default, the plot zooms into a region near the rossby ridge frequency -2(Omega_02pi)(m+1), so one may need to zoom out to look at eigenvalues that are not visible in this plot","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"We may plot one eigenvector — e.g. the 12th eigenvector corresponding to m=5 — as","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"julia> eigenfunction(Feig, 5, 12)","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"This produces the following plot:","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"(Image: eigvec)","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"By default, this plots the real part of V, but the field and component to be plotted may be specified through parameters to eigenfunction. Alternately, all the components of all the fields may be plotted using eigenfunctions_allstreamfn.","category":"page"},{"location":"","page":"Using the code","title":"Using the code","text":"Help on the plotting functions is available in the REPL, which may be accessed through the ? key. So e.g. ?spectrum will display a detailed list of parameters that may be passed to spectrum.","category":"page"},{"location":"API/#API","page":"Library","title":"API","text":"","category":"section"},{"location":"API/#Public-API","page":"Library","title":"Public API","text":"","category":"section"},{"location":"API/","page":"Library","title":"Library","text":"radial_operators\nRotMatrix\nmass_matrix\nmass_matrix!\nuniform_rotation_matrix\nuniform_rotation_matrix!\ndifferential_rotation_matrix\ndifferential_rotation_matrix!\nuniform_rotation_spectrum\nuniform_rotation_spectrum!\ndifferential_rotation_spectrum\ndifferential_rotation_spectrum!\nfilter_eigenvalues\nsave_eigenvalues\nFilteredEigen\nFilteredEigen(filename::String)\ndatadir","category":"page"},{"location":"API/#RossbyWaveSpectrum.radial_operators","page":"Library","title":"RossbyWaveSpectrum.radial_operators","text":"radial_operators(nr, nℓ;\n    r_in_frac = 0.6,\n    r_out_frac = 0.985,\n    ν = 5e11,\n    trackingrate = :hanson2020,\n    scalings = DefaultScalings,\n    superadiabaticityparams = (;))\n\nCompute the Chebyshev-basis representation of radial operators such as derivatives and factors that appear in the differential equations. The positional arguments nr and nℓ specify the number of radial and latitudinal coefficients in the stream functions.\n\nnote: Note\nThe number of coefficients in the factors are chosen adaptively, and are unrelated to the arguments nr and nℓ.\n\nKeyword arguments\n\nr_in_frac: inner boundary of the domain as a fraction of the solar radius\nr_out_frac: outer boundary of the domain as a fraction of the solar radius\nν: coefficient of viscosity, in CGS units\ntrackingrate: the tracking rate Ω0. This may either by a number, or one of   :hanson2020 (corresponding to 453.1 nHz),   :carrington (corresponding to 456 nHz),   :cutoff (corresponding to the rotation rate at the equator at r = r_out_frac * Rsun), or   :surface (corresponding to the rotation rate at the equator at r = Rsun).\nsuperadiabaticityparams: NamedTuple of parameters used to choose the superadiabaticity model.   Values specified here are passed on to superadiabaticity, and these supersede the defaults in   that function. This is empty by default.\nscalings: scalings applied to the equations to improve the balancing of the matrices to be diagonalized.   Default values are (; Wscaling = 1e1, Sscaling = 1e3, Weqglobalscaling = 1e-4, Seqglobalscaling = 1.0),   which should typically be good enough. The interpretation is that the fields that feature in the eigenvalue   problem are (V, Wscaling * W, Sscaling * S) and the equations for W and S are multiplied by Weqglobalscaling   and Seqglobalscaling respectively. Such scalings leave the eigenvalues unchanged.\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.RotMatrix","page":"Library","title":"RossbyWaveSpectrum.RotMatrix","text":"RotMatrix(::Val{:matrix}, V_symmetric::Bool, rotation_profile::Symbol; operators, kw...)\nRotMatrix(::Val{:spectrum}, V_symmetric::Bool, rotation_profile::Symbol; operators, kw...)\n\nStruct containing the spectral decomposition of the rotation profile and the vorticity profile associated with differential rotation in the Sun, along with information about the parity of the solutions that are sought and the function that is to be used to generate the matrices.\n\nA RotMatrix R may be called with arguments as R(args...; kwargs....).  If R was created using Val(:matrix), this will return the matrix representation of the operator A that features in the eigenvalue problem Amathbfv=(ωΩ_0)Bmathbfv. These matrices are computed using the rotation profile that R is constructed with. On the other hand, if R was created using Val(:spectrum) as the first argument, this will return the filtered spectrum and eigenvectors.\n\n\n\n\n\n","category":"type"},{"location":"API/#RossbyWaveSpectrum.mass_matrix","page":"Library","title":"RossbyWaveSpectrum.mass_matrix","text":"mass_matrix(m::Integer;\n    operators,\n    V_symmetric::Bool)\n\nCompute the mass matrix B that features in the eigenvalue problem Amathbfv=(omegaOmega_0)Bmathbfv for a specific m.\n\nKeyword arguments\n\noperators: obtained as the output of radial_operators\nV_symmetric: set to true or false depending on   whether the stream function V is latitudinally symmetric or antisymmtric about the equator.\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.mass_matrix!","page":"Library","title":"RossbyWaveSpectrum.mass_matrix!","text":"mass_matrix!(B, m::Integer;\n    operators,\n    V_symmetric::Bool)\n\nCompute the mass matrix B that features in the eigenvalue problem Amathbfv=(omegaOmega_0)Bmathbfv for a specific m. This operates in-place on the pre-allocated matrix B, and overwrites it with the result. The matrix B may be allocated using allocate_mass_matrix.\n\nSee mass_matrix for further details.\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.uniform_rotation_matrix","page":"Library","title":"RossbyWaveSpectrum.uniform_rotation_matrix","text":"uniform_rotation_matrix(m::Integer; operators, V_symmetric::Bool)\n\nCompute the operator matrix A that features in the eigenvalue problem Amathbfv=(omegaOmega_0)Bmathbfv for a specific m, assuming that the Sun is rotating like a solid body. The matrix would therefore not contain any terms corresponding to differential rotation.\n\nKeyword arguments\n\noperators: obtained as the output of radial_operators\nV_symmetric: set to true or false depending on   whether the stream function V is latitudinally symmetric or antisymmtric about the equator.\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.uniform_rotation_matrix!","page":"Library","title":"RossbyWaveSpectrum.uniform_rotation_matrix!","text":"uniform_rotation_matrix!(A, m::Integer; operators, V_symmetric::Bool)\n\nCompute the operator matrix A that features in the eigenvalue problem Amathbfv=(omegaOmega_0)Bmathbfv for a specific m, assuming that the Sun is rotating like a solid body. This operates in-place on the pre-allocated matrix A, and overwrites it with the output. The matrix A may be allocated using allocate_operator_matrix.\n\nSee uniform_rotation_matrix for further details.\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.differential_rotation_matrix","page":"Library","title":"RossbyWaveSpectrum.differential_rotation_matrix","text":"differential_rotation_matrix(m::Integer;\n    operators, rotation_profile::Symbol, V_symmetric::Bool, kw...)\n\nReturn the operator matrix A that features in the eigenvalue problem Amathbfv=(omegaOmega_0)Bmathbfv for a specified azimuthal order m, assuming a differentially rotating model of the Sun. The profile of rotation may be specified using the keyword argument rotation_profile.\n\nKeyword arguments\n\noperators: obtained as the output of radial_operators\nV_symmetric: set to true or false depending on   whether the stream function V is latitudinally symmetric or antisymmtric about the equator.\nrotation_profile: label to select the rotation profile used to compute the spectrum.   See solar_differential_rotation_profile_derivatives_grid for the list of possible options.\n\nAdditional keyword arguments will be passed on to the specific functions populating the matrix elements, such as solar_differential_rotation_terms!.\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.differential_rotation_matrix!","page":"Library","title":"RossbyWaveSpectrum.differential_rotation_matrix!","text":"differential_rotation_matrix!(A, m::Integer;\n    operators, rotation_profile::Symbol, V_symmetric::Bool, kw...)\n\nCompute the operator matrix A that features in the eigenvalue problem Amathbfv=(omegaOmega_0)Bmathbfv for a specified azimuthal order m assuming a differentially rotating model of the Sun, and store the result in A (which will be overwritten).\n\nSee differential_rotation_matrix for further details.\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.uniform_rotation_spectrum","page":"Library","title":"RossbyWaveSpectrum.uniform_rotation_spectrum","text":"uniform_rotation_spectrum(m::Integer; operators, V_symmetric::Bool)\n\nCompute the inertial-mode spectrum for the specified azimuthal order m, assuming that the Sun is rotating like a solid body, and it is being tracked from a frame that is rotating at the same rate as the Sun. This solves the eigenvalue problem Amathbfv=(omegaOmega_0)Bmathbfv and returns (ω_over_Ω0, v, (A,B)), where ω_over_Ω0 is a vector of eigenvalues, and v is a matrix whose columns are the eigenvectors. A is computed internally by calling uniform_rotation_matrix!, and B is computed by calling mass_matrix!.\n\nnote: Note\nThis function returns all the eigenvalues and eigenfunctions without applying any filtering.\n\nKeyword arguments\n\noperators: obtained as the output of radial_operators\nV_symmetric: set to true or false depending on   whether the stream function V is latitudinally symmetric or antisymmtric about the equator.\nrotation_profile: label to select the rotation profile used to compute the spectrum.   See solar_differential_rotation_profile_derivatives_grid for the list of possible options.\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.uniform_rotation_spectrum!","page":"Library","title":"RossbyWaveSpectrum.uniform_rotation_spectrum!","text":"uniform_rotation_spectrum!((A, B), m::Integer; operators, V_symmetric::Bool)\n\nCompute the inertial-mode spectrum for the specified azimuthal order m, assuming that the Sun is rotating like a solid body, and it is being tracked from a frame that is rotating at the same rate as the Sun. This overwrites the pre-allocated pencil matrices (A, B).\n\nSee uniform_rotation_spectrum for further details.\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.differential_rotation_spectrum","page":"Library","title":"RossbyWaveSpectrum.differential_rotation_spectrum","text":"differential_rotation_spectrum(m::Integer; operators,\n    V_symmetric::Bool, rotation_profile::Symbol, kw...)\n\nCompute the inertial-mode spectrum for the specified azimuthal order m, assuming that the Sun is rotating with a solar-like rotation profile (the exact model may be specified using rotation_profile), and it is being tracked in a frame rotating at a rate Ω0 = operators.constants[:Ω0].\n\nThis solves the eigenvalue problem Amathbfv=(omegaOmega_0)Bmathbfv and returns (ω_over_Ω0, v, (A,B)), where ω_over_Ω0 is a vector of eigenvalues, and v is a matrix whose columns are the eigenvectors. A is computed internally by calling differential_rotation_matrix!,  and B is computed by calling mass_matrix!.\n\nnote: Note\nThis function returns all the eigenvalues and eigenfunctions without applying any filtering.\n\nKeyword arguments\n\noperators: obtained as the output of radial_operators\nV_symmetric: set to true or false depending on   whether the stream function V is latitudinally symmetric or antisymmtric about the equator.\nrotation_profile: label to select the rotation profile used to compute the spectrum.   See solar_differential_rotation_profile_derivatives_grid for the list of possible options.\n\nAdditional keyword arguments are forwarded to differential_rotation_spectrum!.\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.differential_rotation_spectrum!","page":"Library","title":"RossbyWaveSpectrum.differential_rotation_spectrum!","text":"differential_rotation_spectrum!((A, B), m::Integer; operators,\n    V_symmetric::Bool, rotation_profile::Symbol, kw...)\n\nCompute the inertial-mode spectrum for the specified azimuthal order m, assuming that the Sun is rotating with a solar-like rotation profile (the exact model may be specified using rotation_profile), and it is being tracked in a frame rotating at a rate Ω0 = operators.constants[:Ω0]. This overwrites the pre-allocated pencil matrices (A, B).\n\nSee differential_rotation_spectrum for further details.\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.filter_eigenvalues","page":"Library","title":"RossbyWaveSpectrum.filter_eigenvalues","text":"filter_eigenvalues(ω_over_Ω0::AbstractVector{<:Number},\n    v::AbstractMatrix{<:Number},\n    (A,B), m::Integer;\n    operators,\n    V_symmetric::Bool,\n    constraints = RossbyWaveSpectrum.constraintmatrix(operators),\n    filtercache = RossbyWaveSpectrum.allocate_filter_caches(m; operators, constraints),\n    scale_eigenvectors::Bool = false,\n    filterflags = RossbyWaveSpectrum.DefaultFilter,\n    filterparams...)\n\nFilter the set of eigenvalue-eigenvector pairs (ω_over_Ω0, v) for a specified azimuthal order m to remove the potentially spurious ones. This returns a filtered set (ω_over_Ω0f, vf). The eigenvalue pencil (A,B) should be provided if Filters.EIGEN in filterflags, and will be used in the filtering process. Otherwise, the parameters (A,B) are ignored.\n\nKeyword arguments\n\noperators: obtained as the output of radial_operators\nV_symmetric: set to true or false depending on   whether the stream function V is latitudinally symmetric or antisymmtric about the equator.\nconstraints: boundary condition constraints on the spectral coefficients, optional\nfiltercache: pre-allocated workspace used in the filtering process, optional\nscale_eigenvectors: flag to indices whether to compute the unscaled stream functions   from the scaled ones that are used in the eigenvalue problem.\nfilterflags: the flags that specify which filters are used, optional.   See Filters for a list of possible flags.\nfilterparams: additional filter parameters, passed on to filterfn. See   RossbyWaveSpectrum.DefaultFilterParams for the full list of parameters   that may be specified, and their default values.    The parameters specified in filterparams override the default values.\n\n\n\n\n\nfilter_eigenvalues(ω_over_Ω0s::AbstractVector{<:AbstractVector{<:Number}},\n    vs::AbstractVector{<:AbstractMatrix{<:Number}},\n    mr::AbstractVector{<:Integer};\n    matrixfn!,\n    operators,\n    V_symmetric::Bool,\n    constraints = RossbyWaveSpectrum.constraintmatrix(operators),\n    filtercache = RossbyWaveSpectrum.allocate_filter_caches(m; operators, constraints),\n    filterflags = RossbyWaveSpectrum.DefaultFilter,\n    filterparams...)\n\nFilter the sets of eigenvalue-eigenvector pairs (ω_over_Ω0, v) for each azimuthal order m in the range mr, taken from the vectors ω_over_Ω0s and vs. The filtering operation for each m is independent of the others, and these are therefore carried out in parallel if multiple threads are available. This function returns a filtered set (ω_over_Ω0sf, vsf), where ω_over_Ω0sf[i] and vsf[i] represents the filtered set of eigenvalues and eigenvectors corresponding to m = mr[i].\n\nKeyword arguments\n\nmatrixfn!: The function used to compute the matrix A in the eigenvalue pencil (A,B). This may be one of uniform_rotation_matrix! or differential_rotation_matrix! or a RotMatrix, and will be called as matrixfn!(A, m; kw...) to populate the matrix A.\noperators: obtained as the output of radial_operators\nV_symmetric: set to true or false depending on   whether the stream function V is latitudinally symmetric or antisymmtric about the equator.\nconstraints: Boundary condition constraints on the spectral coefficients, optional\nfiltercache: Pre-allocated workspace used in the filtering process, optional\nfilterflags: The flags that specify which filters are used, optional.   See Filters for a list of possible flags.\nfilterparams: additional filter parameters, passed on to filterfn. See   RossbyWaveSpectrum.DefaultFilterParams for the full list of parameters   that may be specified.\n\n\n\n\n\nfilter_eigenvalues(spectrumfn!,\n    mr::AbstractVector;\n    operators,\n    V_symmetric,\n    constraints = RossbyWaveSpectrum.constraintmatrix(operators),\n    filtercache = RossbyWaveSpectrum.allocate_filter_caches(m; operators, constraints),\n    filterflags = RossbyWaveSpectrum.DefaultFilter,\n    filterparams...)\n\nCompute the spectrum of inertial waves for the specified range of azimuthal orders mr, and filter the solutions to remove potentially spurious solutions. This function returns (ω_over_Ω0s, vs), where ω_over_Ω0s[i] and vs[i] represent the filtered set of eigenvalues and eigenvectors corresponding to m = mr[i].\n\nThe argument spectrumfn! must be one of uniform_rotation_spectrum! or differential_rotation_spectrum!.\n\nKeyword arguments\n\noperators: obtained as the output of radial_operators\nV_symmetric: set to true or false depending on   whether the stream function V is latitudinally symmetric or antisymmtric about the equator.\nconstraints: Boundary condition constraints on the spectral coefficients, optional\nfiltercache: Pre-allocated workspace used in the filtering process, optional\nfilterflags: The flags that specify which filters are used, optional.   See Filters for a list of possible flags.\nfilterparams: additional filter parameters, passed on to filterfn. See   RossbyWaveSpectrum.DefaultFilterParams for the full list of parameters   that may be specified, and their default values.    The parameters specified in filterparams override the default values.\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.save_eigenvalues","page":"Library","title":"RossbyWaveSpectrum.save_eigenvalues","text":"save_eigenvalues(spectrumfn!, mr; operators, V_symmetric, rotation_profile, kw...)\nsave_eigenvalues(spectrumfn!::RotMatrix, mr; operators, kw...)\n\nCompute the spectra for all azimuthal orders m in mr using the function spectrumfn!, and save the results to disk, with a filename given by rossbyeigenfilename Additional keyword arguments are passed on to filter_eigenvalues and rossbyeigenfilename.\n\nIf spectrumfn! isa RotMatrix, the keyword arguments V_symmetric and rotation_profile are automatically inferred from it.\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.FilteredEigen","page":"Library","title":"RossbyWaveSpectrum.FilteredEigen","text":"FilteredEigen\n\nStruct to hold the filtered eigenvalues and eigenfunctions for a range of m. Given a FilteredEigen F, the eigenfunctions for a specific m may be obtained using F[m], which returns a FilteredEigenSingleOrder.\n\n\n\n\n\n","category":"type"},{"location":"API/#RossbyWaveSpectrum.FilteredEigen-Tuple{String}","page":"Library","title":"RossbyWaveSpectrum.FilteredEigen","text":"FilteredEigen(filename::AbstractString)\n\nLoad the filtered eigenvalues and eigenvectors from filename.\n\n\n\n\n\n","category":"method"},{"location":"API/#RossbyWaveSpectrum.datadir","page":"Library","title":"RossbyWaveSpectrum.datadir","text":"datadir(filename)\n\nPreprend the data directory to the filename. This is a convenience function to make loading files less cumbersome.\n\n\n\n\n\n","category":"function"},{"location":"API/#Post-processing-Filters","page":"Library","title":"Post-processing Filters","text":"","category":"section"},{"location":"API/#Filter-flags","page":"Library","title":"Filter flags","text":"","category":"section"},{"location":"API/","page":"Library","title":"Library","text":"Modules = [RossbyWaveSpectrum.Filters]","category":"page"},{"location":"API/#RossbyWaveSpectrum.Filters","page":"Library","title":"RossbyWaveSpectrum.Filters","text":"Filters\n\nFlags that may be passed to the filterflags keyword argument in filter_eigenvalues to specify which conditions to filter solutions by.\n\nPossible options are:\n\nFilters.NONE\nFilters.EIGEN\nFilters.EIGVAL\nFilters.BC\nFilters.SPATIAL_EQUATOR\nFilters.SPATIAL_RADIAL\nFilters.NODES\n\nThe individual filters may be combined using |, e.g. to include the Filters.EIGEN and the Filters.SPATIAL_EQUATOR flags, use Filters.EIGEN | Filters.SPATIAL_EQUATOR.\n\n\n\n\n\n","category":"module"},{"location":"API/#RossbyWaveSpectrum.Filters.BC","page":"Library","title":"RossbyWaveSpectrum.Filters.BC","text":"Filters.BC\n\nFilter for eigenfunctions that satify the boundary conditions Cmathbfv = 0. Typically, all solutions should satisfy this condition, as this is imposed when solving the eigenvalue problem. See RossbyWaveSpectrum.DefaultFilterParams for the parameters associated with this filter.\n\n\n\n\n\n","category":"constant"},{"location":"API/#RossbyWaveSpectrum.Filters.DefaultFilter","page":"Library","title":"RossbyWaveSpectrum.Filters.DefaultFilter","text":"Filters.DefaultFilter\n\nThe default set of filter flags that are used to constrain the set of solutions. This is defined as\n\njulia> Filters.DefaultFilter\n(NODES | SPATIAL_RADIAL | SPATIAL_EQUATOR | BC | EIGVEC | EIGVAL | EIGEN)::RossbyWaveSpectrum.Filters.FilterFlag = 0x00df\n\n\n\n\n\n","category":"constant"},{"location":"API/#RossbyWaveSpectrum.Filters.EIGEN","page":"Library","title":"RossbyWaveSpectrum.Filters.EIGEN","text":"Filters.EIGEN\n\nFilter for solutions (ω, v) that satisfy the eigenvalue problem Amathbfv=(omegaOmega_0)Bmathbfv. See RossbyWaveSpectrum.DefaultFilterParams for the parameters associated with this filter.\n\n\n\n\n\n","category":"constant"},{"location":"API/#RossbyWaveSpectrum.Filters.EIGVAL","page":"Library","title":"RossbyWaveSpectrum.Filters.EIGVAL","text":"Filters.EIGVAL\n\nFilter for solutions that satisfy constraints on the eigenvalue, e.g. pick out damped solutions and ignore growing ones. See RossbyWaveSpectrum.DefaultFilterParams for the parameters associated with this filter.\n\n\n\n\n\n","category":"constant"},{"location":"API/#RossbyWaveSpectrum.Filters.EIGVEC","page":"Library","title":"RossbyWaveSpectrum.Filters.EIGVEC","text":"Filters.EIGVAL\n\nFilter for smooth eigenfunctions, by applying spectral cutoffs in the Chebyshev order n as well as the spherical-harmonic degree ℓ. See RossbyWaveSpectrum.DefaultFilterParams for the parameters associated with this filter.\n\n\n\n\n\n","category":"constant"},{"location":"API/#RossbyWaveSpectrum.Filters.NODES","page":"Library","title":"RossbyWaveSpectrum.Filters.NODES","text":"Filters.NODES\n\nFilter for eigenfunctions that have fewer than a specified number of radial nodes. A heuristic criteria is applied to ignore zero-crossings due to numerical or resolution limitations. See RossbyWaveSpectrum.DefaultFilterParams for the parameters associated with this filter.\n\n\n\n\n\n","category":"constant"},{"location":"API/#RossbyWaveSpectrum.Filters.NONE","page":"Library","title":"RossbyWaveSpectrum.Filters.NONE","text":"Filters.NONE\n\nDo not apply any filter. This retains all the solutions.\n\n\n\n\n\n","category":"constant"},{"location":"API/#RossbyWaveSpectrum.Filters.SPATIAL_EQUATOR","page":"Library","title":"RossbyWaveSpectrum.Filters.SPATIAL_EQUATOR","text":"Filters.SPATIAL_EQUATOR\n\nFilter for eigenfunctions that latitudinally peak about the solar equator.     See RossbyWaveSpectrum.DefaultFilterParams for the parameters associated with this filter.\n\n\n\n\n\n","category":"constant"},{"location":"API/#RossbyWaveSpectrum.Filters.SPATIAL_RADIAL","page":"Library","title":"RossbyWaveSpectrum.Filters.SPATIAL_RADIAL","text":"Filters.SPATIAL_RADIAL\n\nFilter for eigenfunctions where the power is not concentrated very close to the top and the bottom boundaries of the domain. See RossbyWaveSpectrum.DefaultFilterParams for the parameters associated with this filter.\n\n\n\n\n\n","category":"constant"},{"location":"API/#Filtering-functions","page":"Library","title":"Filtering functions","text":"","category":"section"},{"location":"API/","page":"Library","title":"Library","text":"RossbyWaveSpectrum.eigensystem_satisfy_filter\nRossbyWaveSpectrum.eigvec_spectrum_filter\nRossbyWaveSpectrum.spatial_filter\nRossbyWaveSpectrum.eigenvalue_filter\nRossbyWaveSpectrum.boundary_condition_filter","category":"page"},{"location":"API/#RossbyWaveSpectrum.eigensystem_satisfy_filter","page":"Library","title":"RossbyWaveSpectrum.eigensystem_satisfy_filter","text":"eigensystem_satisfy_filter(ω_over_Ω0::Number,\n    v::StructVector{<:Complex},\n    (A,B)::NTuple{2,AbstractMatrix{<:Number}},\n    MVcache = RossbyWaveSpectrum.allocate_MVcache(size(A, 1));\n    rtol = RossbyWaveSpectrum.DefaultFilterParams[:eigen_rtol])\n\nReturn whether the eigenvalue ω_over_Ω0 and eigenvector v satisfy Amathbfv=(omegaOmega_0) Bmathbfv to within the relative tolerance rtol.\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.eigvec_spectrum_filter","page":"Library","title":"RossbyWaveSpectrum.eigvec_spectrum_filter","text":"eigvec_spectrum_filter(v::AbstractVector{<:Number}, m::Integer;\n    operators,\n    n_cutoff = RossbyWaveSpectrum.DefaultFilterParams[:n_cutoff],\n    Δl_cutoff = RossbyWaveSpectrum.DefaultFilterParams[:Δl_cutoff],\n    eigvec_spectrum_power_cutoff = RossbyWaveSpectrum.DefaultFilterParams[:eigvec_spectrum_power_cutoff],\n    filterfieldpowercutoff = RossbyWaveSpectrum.DefaultFilterParams[:filterfieldpowercutoff],\n    low_n_power_lowercutoff = RossbyWaveSpectrum.DefaultFilterParams[:eigvec_spectrum_low_n_power_fraction_cutoff],\n    kw...)\n\nReturn if the eigenvector v is smooth enough, according to the specified criteria.\n\n\n\n\n\neigvec_spectrum_filter(Feig::FilteredEigen, m::Integer, ind::Integer; kw...)\n\nReturn if the eigenvector ind-th eigenvector of Feig[m] is smooth enough, according to the specified criteria. By default, the filter parameters are taken to be identical to those used to compute the solutions in Feig, but each of these parameters may be overridden.\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.spatial_filter","page":"Library","title":"RossbyWaveSpectrum.spatial_filter","text":"spatial_filter(v::AbstractVector{<:Number}, m::Integer;\n    operators,\n    filtercache = RossbyWaveSpectrum.allocate_filter_caches(m; operators),\n    θ_cutoff = RossbyWaveSpectrum.DefaultFilterParams[:θ_cutoff],\n    equator_power_cutoff_frac = RossbyWaveSpectrum.DefaultFilterParams[:equator_power_cutoff_frac],\n    pole_cutoff_angle = RossbyWaveSpectrum.DefaultFilterParams[:pole_cutoff_angle],\n    pole_power_cutoff_frac = RossbyWaveSpectrum.DefaultFilterParams[:pole_power_cutoff_frac],\n    filterfieldpowercutoff = RossbyWaveSpectrum.DefaultFilterParams[:filterfieldpowercutoff],\n    radial_topbotpower_cutoff = RossbyWaveSpectrum.DefaultFilterParams[:radial_topbotpower_cutoff],\n    kw...)\n\nReturn if the eigenvector v for the azimuthal order m is spatially localized according to the specified parameters.\n\n\n\n\n\nspatial_filter(Feig::FilteredEigen, m::Integer, ind::Integer; kw...)\n\nReturn if the ind-th eigenvector of Feig[m] is spatially localized according to the specified parameters. By default, the filter parameters are taken to be identical to those used to compute the solutions in Feig, but each of these parameters may be overridden.\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.eigenvalue_filter","page":"Library","title":"RossbyWaveSpectrum.eigenvalue_filter","text":"eigenvalue_filter(ω_over_Ω0, m;\n    eig_imag_unstable_cutoff = RossbyWaveSpectrum.DefaultFilterParams[:eig_imag_unstable_cutoff],\n    eig_imag_to_real_ratio_cutoff = RossbyWaveSpectrum.DefaultFilterParams[:eig_imag_to_real_ratio_cutoff],\n    eig_imag_stable_cutoff = RossbyWaveSpectrum.DefaultFilterParams[:eig_imag_stable_cutoff])\n\nReturn if the eigenvalue ω_over_Ω0 represents a damped eigenfunction.\n\nKeyword arguments\n\neig_imag_unstable_cutoff: lower cutoff below which modes are considered growing. This is slightly less than   zero to account for numerical errors.\neig_imag_to_real_ratio_cutoff: cutoff ratio of linewidth to central frequency to filter out strongly damped modes.\neig_imag_stable_cutoff: absolute cutoff on linewidth to filter out strongly damped modes.\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.boundary_condition_filter","page":"Library","title":"RossbyWaveSpectrum.boundary_condition_filter","text":"boundary_condition_filter(v::StructVector{<:Complex},\n    BC::AbstractMatrix{<:Real},\n    BCVcache::StructVector{<:Complex} = RossbyWaveSpectrum.allocate_BCcache(size(BC,1)),\n    atol = 1e-5)\n\nReturn if the eigenfunction with spectral coefficients v satisfies the boundary conditions within the absoute tolerance atol. The boundary-condition matrix BC may be obtained from constraintmatrix.\n\n\n\n\n\n","category":"function"},{"location":"API/#Validation","page":"Library","title":"Validation","text":"","category":"section"},{"location":"API/","page":"Library","title":"Library","text":"RossbyWaveSpectrum.constant_differential_rotation_terms!","category":"page"},{"location":"API/#RossbyWaveSpectrum.constant_differential_rotation_terms!","page":"Library","title":"RossbyWaveSpectrum.constant_differential_rotation_terms!","text":"constant_differential_rotation_terms!(A, m::Integer;\n    operators,\n    V_symmetric::Bool,\n    ΔΩ_frac = 0.01)\n\nCompute the operator matrix A that features in the eigenvalue problem Amathbfv=(omegaOmega_0)Bmathbfv for a specific m, assuming that the Sun is rotating like a solid body, albeit at a rotation speed Ω that exceeds the tracking rate Ω_0 by the specified ratio ΔΩ_frac (i.e. Ω = Ω0 * (1 + ΔΩ_frac)). This function serves as a validation test for the differentially rotating model.\n\nThis function overwrites the input matrix A that is obtained as the output to uniform_rotation_matrix, and adds the extra terms corresponding to the difference in rotation rates to it.\n\nKeyword arguments\n\noperators: obtained as the output of radial_operators\nV_symmetric: set to true or false depending on   whether the stream function V is latitudinally symmetric or antisymmtric about the equator.\nΔΩ_frac: Ratio by which the background rotation rate Ω exceeds the reference rate Ω_0.   The relation between the two is given by Ω = Ω_0 * (1 + ΔΩ_frac).\n\n\n\n\n\n","category":"function"},{"location":"API/#Lower-level-utilities","page":"Library","title":"Lower level utilities","text":"","category":"section"},{"location":"API/","page":"Library","title":"Library","text":"RossbyWaveSpectrum.DefaultFilterParams\nRossbyWaveSpectrum.filterfn\nRossbyWaveSpectrum.solar_differential_rotation_terms!\nRossbyWaveSpectrum.solar_differential_rotation_profile_derivatives_grid\nRossbyWaveSpectrum.solar_differential_rotation_profile_derivatives_Fun\nRossbyWaveSpectrum.solar_differential_rotation_vorticity_Fun\nRossbyWaveSpectrum.constraintmatrix\nRossbyWaveSpectrum.superadiabaticity\nRossbyWaveSpectrum.eigenfunction_realspace\nRossbyWaveSpectrum.compute_constrained_matrix\nRossbyWaveSpectrum.compute_constrained_matrix!\nRossbyWaveSpectrum.constrained_eigensystem\nRossbyWaveSpectrum.constrained_matmul_cache\nRossbyWaveSpectrum.allocate_operator_matrix\nRossbyWaveSpectrum.allocate_mass_matrix\nRossbyWaveSpectrum.allocate_operator_mass_matrices\nRossbyWaveSpectrum.allocate_filter_caches\nRossbyWaveSpectrum.allocate_projectback_temp_matrices\nRossbyWaveSpectrum.operator_matrices\nRossbyWaveSpectrum.rossbyeigenfilename\nRossbyWaveSpectrum.FilteredEigenSingleOrder\nRossbyWaveSpectrum.colatitude_grid\nRossbyWaveSpectrum.allocate_MVcache\nRossbyWaveSpectrum.allocate_BCcache","category":"page"},{"location":"API/#RossbyWaveSpectrum.DefaultFilterParams","page":"Library","title":"RossbyWaveSpectrum.DefaultFilterParams","text":"DefaultFilterParams\n\nDefault list of parameters that are used in the filtering process. The full list is:\n\nconst DefaultFilterParams = Dict(\n    # boundary condition filter: Filters.BC\n    :bc_atol => 1e-5, # absolute tolerance to which boundary conditions must be satisfied\n    # eigval filter: Filters.EIGVAL\n    :eig_imag_unstable_cutoff => -1e-6, # absolute lower cutoff below which modes are considered to be exponentially growing\n    :eig_imag_to_real_ratio_cutoff => 3, # relative upper cutoff on linewidths\n    :eig_imag_stable_cutoff => 0.2, # absolute upper cutoff on linewidths\n    # eigensystem satisfy filter: Filters.EIGEN\n    :eigen_rtol => 0.01, # tolerance above which modes are rejected\n    # smooth eigenvector filter: Filters.EIGVEC\n    :Δl_cutoff => 7, # spherical harmonic degree\n    :n_cutoff => 10, # chebyshev order\n    :eigvec_spectrum_power_cutoff => 0.5, # fraction of total power required below cutoffs\n    :eigvec_spectrum_low_n_power_fraction_cutoff => 1, # maximum ratio of total power above n_cutoff to total power below n_cutoff\n    # spatial localization filter: Filters.SPATIAL\n    :θ_cutoff => deg2rad(45), # colatitude below which a mode is considered equatorial\n    :equator_power_cutoff_frac => 0.4, # minimum fraction of power that lie below θ_cutoff for equatorial modes\n    :pole_cutoff_angle => deg2rad(25), # colatitude above which a mode is considered polar\n    :pole_power_cutoff_frac => 0.05, # maximum fraction of power that may be near poles for equatorial modes\n    :radial_topbotpower_cutoff => 0.7, # upper cutoff for power in the top and bottom 10% of the radial domain\n    # radial nodes filter # Filters.NODES\n    :nnodesmax => 5, # maximum number of radial nodes in either the real or imaginary component of the eigenfunction\n    :nodessmallpowercutoff => 0.05, # minimum fractional power between roots beyond which a zero-crossing is considered real\n    # exclude a field from filters if relative power is below a cutoff\n    :filterfieldpowercutoff => 1e-2,\n)\n\nEach parameter may be passed as a keyword argument to filter_eigenvalues.\n\n\n\n\n\n","category":"constant"},{"location":"API/#RossbyWaveSpectrum.filterfn","page":"Library","title":"RossbyWaveSpectrum.filterfn","text":"filterfn(λ::Number,\n    v::AbstractVector{<:Number},\n    m::Integer,\n    (A,B);\n    operators,\n    V_symmetric,\n    constraints = RossbyWaveSpectrum.constraintmatrix(operators),\n    filtercache = RossbyWaveSpectrum.allocate_filter_caches(m; operators, constraints),\n    filterflags = RossbyWaveSpectrum.DefaultFilter,\n    filterparams...)\n\nReturn whether one eigenvalue and eigenvector pair (λ, v) for the azimuthal order m satisfy the chosen filters. The matrices (A,B) represent the pencil.\n\nKeyword arguments\n\noperators: obtained as the output of radial_operators.\nV_symmetric: set to true or false depending on   whether the stream function V is latitudinally symmetric or antisymmtric about the equator.\nconstraints: boundary condition constraints on the spectral coefficients, optional.\nfiltercache: pre-allocated workspace used in the filtering process, optional.\nfilterflags: the flags that specify which filters are used, optional.   See Filters for a list of possible flags.\nfilterparams: additional filter parameters to override the default ones   from RossbyWaveSpectrum.DefaultFilterParams.   The parameters specified in filterparams will override the default values,   and the ones left unspecified will be set to the default values.\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.solar_differential_rotation_terms!","page":"Library","title":"RossbyWaveSpectrum.solar_differential_rotation_terms!","text":"solar_differential_rotation_terms!(A, m::Integer;\n    operators,\n    V_symmetric::Bool,\n    rotation_profile::Symbol,\n    ΔΩ_frac = 0.01, # only used to test the constant case\n    ΔΩ_scale = 1, # scale the diff rot profile\n    kw...)\n\nCompute the operator matrix A that features in the eigenvalue problem Amathbfv=(omegaOmega_0)Bmathbfv for a specific m, assuming that the Sun is rotating with a solar-like rotation profile. The keyword argument rotation_profile specifies the specific model that is chosen. Optionally, additional keyword arguments kw may be passed to alter the specifics of the model. These are detailed below.\n\nThis function overwrites the input matrix A that is obtained as the output to uniform_rotation_matrix, and adds the extra terms corresponding to differential rotation to it.\n\nKeyword arguments\n\noperators: obtained as the output of radial_operators\nV_symmetric: set to true or false depending on   whether the stream function V is latitudinally symmetric or antisymmtric about the equator.\nrotation_profile: label to select the rotation profile used to compute the spectrum.   See solar_differential_rotation_profile_derivatives_grid for the list of possible options.\nΔΩ_frac: ratio by which the background rotation rate Ω exceeds the reference rate Ω_0, optional.   The relation between the two is given by Ω = Ω_0 * (1 + ΔΩ_frac).   This is only used if rotation_profile == :constant, and is chosen to be 0.01 by default.\nΔΩ_scale: factor by which the differential rotation profile may be scaled. This may be used to   tune the differential rotation to trace the results back to the solid-body rotation case.\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.solar_differential_rotation_profile_derivatives_grid","page":"Library","title":"RossbyWaveSpectrum.solar_differential_rotation_profile_derivatives_grid","text":"solar_differential_rotation_profile_derivatives_grid(;\n    operators,\n    rotation_profile,\n    ΔΩ_frac = 0.01,\n    kw...)\n\nReturn the smoothed spatial profile of rotation, corresponding to the model specified by rotation_profile. This function reads in rotation model files, and interpolates the profile on to Chebyshev nodes in both the radial and angular coordinates through smoothing splines. This spatial profile is subsequently transformed to spectral coefficients in solar_differential_rotation_profile_derivatives_Fun.\n\nTypically, this is used to load the solar rotation profile, but other profiles may be specified for testing the code.\n\nKeyword arguments\n\noperators: obtained as the output of radial_operators\nrotation_profile: the flag that chooses the model of the rotation profile. Possible options are:\n:solar_latrad: Smoothed solar rotation profile, limited to the radial domain\n:solar_latrad_squished: Same as latrad, except the solar surface is projected to the outer boundary of the radial domain.\n:solar_radial_equator: smoothed radial profile of the solar equatorial rotation rate, but limited to the radial domain. This corresponds to the radial profile of the latrad model at the equator.\n:solar_radial_equator_squished: same profile as radial_equator, except that the solar surface is projected onto the outer boundary of the radial domain. This corresponds to the radial profile of the latrad_squished model at the equator.\n:solar_constant: background medium rotates like a solid body, at a rate Ω that differs from the tracking rate Ω0\nΔΩ_frac: In case rotation_profile == :solar_constant, the factor by which the tracking rate Ω0 is increased   to obtain the rotation rate of the background medium.\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.solar_differential_rotation_profile_derivatives_Fun","page":"Library","title":"RossbyWaveSpectrum.solar_differential_rotation_profile_derivatives_Fun","text":"solar_differential_rotation_profile_derivatives_Fun(;\n    operators,\n    rotation_profile,\n    ΔΩ_smoothing_param = 5e-2,\n    kw...)\n\nCompute the Chebyshev-Ultraspherical decomposition of the rotation profile specified by rotation_profile, which typically is a smoothed version of the solar rotation profile. The keyword arguments kw are passed on to solar_differential_rotation_profile_derivatives_grid.\n\nReturns a collection (; ΔΩ, dr_ΔΩ, d2r_ΔΩ, dz_ΔΩ), where the first term is the spectral approximation to the profile of differential rotation, and the subsequent terms are radial and z-derivatives.\n\nKeyword arguments\n\noperators: obtained as the output of radial_operators\nrotation_profile: the flag that chooses the model of the rotation profile.   See solar_differential_rotation_profile_derivatives_grid for possible options.\nΔΩ_smoothing_param: the extent of smoothing applied to the rotation profile before performing the spectral   transform. Typically, this should be small to match the original profile closely, with the tradeoff   being in the number of spectral coefficients that are necessary to represent the model.\nkw: Optional keyword arguments that are passed on to solar_differential_rotation_profile_derivatives_grid.\n\n\n\n\n\nsolar_differential_rotation_profile_derivatives_Fun(Feig::FilteredEigen; kw...)\n\nReturn the profile of background rotation that was used to compute the spectrum contained in Feig. Additional keyword arguments kw may be supplied to override the ones in Feig.\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.solar_differential_rotation_vorticity_Fun","page":"Library","title":"RossbyWaveSpectrum.solar_differential_rotation_vorticity_Fun","text":"solar_differential_rotation_vorticity_Fun(; operators, ΔΩprofile_deriv)\n\nReturn the spectral approximation to the vorticity associated with differential rotation  left(boldsymbolω_Omega =   (Ω hatz)right), given the rotation profile Ω and its derivatives.\n\nKeyword arguments\n\noperators: obtained as the output of radial_operators\nΔΩprofile_deriv: Collection containing the rotation profile and its derivatives, obtained from   solar_differential_rotation_profile_derivatives_Fun.\n\n\n\n\n\nsolar_differential_rotation_vorticity_Fun(Feig::FilteredEigen; kw...)\n\nReturn the profile of vorticity associated with background rotation that was used to compute the spectrum contained in Feig. Additional keyword arguments in kw may be used to override the ones in Feig.\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.constraintmatrix","page":"Library","title":"RossbyWaveSpectrum.constraintmatrix","text":"constraintmatrix(operators)\n\nReturn a collection containing the spectral representation of the boundary condition operator BC, and a basis ZC whose columns lie in its null-space. The operators may be obtained using radial_operators.\n\nThe constraint satisfied by the eigenfunctions may be expressed as Cmathbfv=0. Given a matrix Z that satisfies CZ=0, we may express the eigenfunction as mathbfv=Zmathbfw for an arbitrary mathbfw. This function uses the variable names BC for C and ZC for Z.\n\nThe matrices may be destructured as (; BC, ZC) = RossbyWaveSpectrum.constraintmatrix(operators).\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.superadiabaticity","page":"Library","title":"RossbyWaveSpectrum.superadiabaticity","text":"superadiabaticity(r::Real;\n    r_out = Rsun,\n    δcz = 3e-6,\n    δtop = 3e-5,\n    δrad = -1e-3,\n    dtrans = 0.05Rsun,\n    dtop = 0.05Rsun,\n    r_sub = 0.8Rsun,\n    r_tran = 0.725Rsun)\n\nCompute the superadiabaticity profile δ parameterized by the keyword arguments, following Rempel (2005), ApJ 622:1320 –1332, section 2.3.\n\nKeyword arguments\n\nδcz: representative value of superadiabaticity δ in the bulk of the convection zone\nδtop: representative value of superadiabaticity δ at the surface\nδrad: representative value of superadiabaticity δ in the radiative interior\ndtrans: scale over which the profile in the radiative zone transitions to that in the convection zone\ndtop: scale over which the profile in the convection zone transitions to that at the surface\nr_tran: radius below which the radiative profile transitions to strongly subadiabatic (in the overshoot region)\nr_sub: radius below which the radiative profile transitions to weakly subadiabatic within the convection zone\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.eigenfunction_realspace","page":"Library","title":"RossbyWaveSpectrum.eigenfunction_realspace","text":"eigenfunction_realspace(v, m; operators, V_symmetric::Bool,\n    n_lowpass_cutoff = nothing,\n    Δl_lowpass_cutoff = nothing)\n\nCompute the real-space eigenfunctions from the spectral coefficients v for the azimuthal order m.\n\nKeyword arguments\n\noperators: obtained as the output of radial_operators\nV_symmetric: set to true or false depending on   whether the stream function V is latitudinally symmetric or antisymmtric about the equator.\nn_lowpass_cutoff: maximum chebyshev order n to retain in the inverse transform, optional.   If no value is provided, all the coefficients are used (default).\nΔl_lowpass_cutoff: maximum harmonic order ℓ to retain in the inverse transform, optional.   If no value is provided, all the coefficients are used (default).\n\n\n\n\n\neigenfunction_realspace(Feig::FilteredEigen, m, ind; kw...)\n\nReturn the real-space eigenfunction from the ind-th eigenvector for the azimuthal order m, taken from the full list of solutions Feig.\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.compute_constrained_matrix","page":"Library","title":"RossbyWaveSpectrum.compute_constrained_matrix","text":"compute_constrained_matrix(A, constraints)\n\nCompute the constrained matrix Z^T A Z given A. Here the columns of Z = constraints.ZC represents the spectral coefficients of a basis that satifies the boundary conditions.\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.compute_constrained_matrix!","page":"Library","title":"RossbyWaveSpectrum.compute_constrained_matrix!","text":"compute_constrained_matrix!(out, constraints, A)\n\nCompute the constrained matrix Z^T A Z given A, and overwrite out with the result. Here the columns of Z = constraints.ZC represents the spectral coefficients of a basis that satifies the boundary conditions.\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.constrained_eigensystem","page":"Library","title":"RossbyWaveSpectrum.constrained_eigensystem","text":"constrained_eigensystem((A, B);\n    operators,\n    constraints = RossbyWaveSpectrum.constraintmatrix(operators),\n    cache = RossbyWaveSpectrum.constrained_matmul_cache(constraints),\n    temp_projectback = RossbyWaveSpectrum.allocate_projectback_temp_matrices(size(constraints.ZC)),\n    kw...)\n\nSolve the eigenvalue problem Amathbfv=(omegaOmega_0)Bmathbfv subject to the boundary-condition constraint Cmathbfv=0, and return (λ, v, (A, B)). The input arguments are the matrix pencil (A, B).\n\nInternally, this computes a matrix Z = constraints.ZC that represents the spectral coefficients of a basis that satifies the boundary conditions (i.e. this satisfies CZ=0). The eigenfunction mathbfv may therefore be expressed as mathbfv = Zmathbfw for an arbitrary mathbfw. Substituting this, and projecting the eigenvalue problem on to the basis Z, we obtain (Z^T A Z)mathbfw = (omegaOmega_0)(Z^T B Z)mathbfw, which is solved numerically. Finally, the eigenfunctions are transformed to the Chebyshev basis using mathbfv = Zmathbfw.\n\nKeyword arguments\n\noperators: obtained as the output of radial_operators\nconstraints: projection matrices to enforce the boundary conditions, optional.\ncache: temporary arrays used in evaluating the constrained matrix pencil (Z^T A Z, Z^T B Z), optional.   See constrained_matmul_cache\ntemp_projectback: temporary arrays used in computing v from w, optional.\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.constrained_matmul_cache","page":"Library","title":"RossbyWaveSpectrum.constrained_matmul_cache","text":"constrained_matmul_cache(constraints)\n\nAllocate temporary matrices that are overwritten with Z^T A Z and Z^T B Z, given the eigenvalue pencil (A B), where the columns of Z = constraints.ZC represent the spectral coefficients of a basis that satifies the boundary conditions.\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.allocate_operator_matrix","page":"Library","title":"RossbyWaveSpectrum.allocate_operator_matrix","text":"allocate_operator_matrix(operators)\n\nAllocate the operator matrix A that features in the eigenvalue problem Amathbfv=(omegaOmega_0)Bmathbfv. The argument operators is obtained as the output of radial_operators.\n\nnote: Note\nThis does not initialize the matrix.\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.allocate_mass_matrix","page":"Library","title":"RossbyWaveSpectrum.allocate_mass_matrix","text":"allocate_mass_matrix(operators)\n\nAllocate the mass matrix B that features in the eigenvalue problem Amathbfv=(omegaOmega_0)Bmathbfv. The argument operators is obtained as the output of radial_operators.\n\nnote: Note\nThis does not initialize the matrix.\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.allocate_operator_mass_matrices","page":"Library","title":"RossbyWaveSpectrum.allocate_operator_mass_matrices","text":"allocate_operator_mass_matrices(operators)\n\nAllocate the eigenvalue pencil matrices (AB). The argument operators is obtained as the output of radial_operators.\n\nnote: Note\nThis does not initialize the matrices.\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.allocate_filter_caches","page":"Library","title":"RossbyWaveSpectrum.allocate_filter_caches","text":"allocate_filter_caches(m; operators,\n    constraints = RossbyWaveSpectrum.constraintmatrix(operators))\n\nAllocate temporary matrices used in the filtering process, given the azimuthal order m.\n\nKeyword arguments\n\noperators: obtained as the output of radial_operators\nconstraints: boundary condition constraints on the spectral coefficients, optional\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.allocate_projectback_temp_matrices","page":"Library","title":"RossbyWaveSpectrum.allocate_projectback_temp_matrices","text":"allocate_projectback_temp_matrices(sz)\n\nAllocate temporary matrices used to project the eigenfunctions for (Z^T A Z)mathbfw = (omegaOmega_0)(Z^T B Z)mathbfw to those for Amathbfv=(omegaOmega_0)Bmathbfv.\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.operator_matrices","page":"Library","title":"RossbyWaveSpectrum.operator_matrices","text":"operator_matrices(Feig::FilteredEigen, m; kw...)\n\nReturn the pencil (A, B) for the azimuthal order m, using the parameters used to compute the eigenvalues in Feig.\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.rossbyeigenfilename","page":"Library","title":"RossbyWaveSpectrum.rossbyeigenfilename","text":"rossbyeigenfilename(; operators, V_symmetric, rotation_profile, modeltag = \"\")\n\nReturn the file name to which the results should be written. The output is a combination of the keyword arguments specifed.\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.FilteredEigenSingleOrder","page":"Library","title":"RossbyWaveSpectrum.FilteredEigenSingleOrder","text":"FilteredEigenSingleOrder\n\nStruct containing the filtered set of eigenvalues and eigenfunctions for a single m. A FilteredEigenSingleOrder is equivalent to a Vector of serial => (eigenvalue, eigenfunction) pairs, with additional metadata stored along with this. Indexing into a FilteredEigenSingleOrder with a serial number should return a (eigenvalue, eigenfunction) pair.\n\n\n\n\n\n","category":"type"},{"location":"API/#RossbyWaveSpectrum.colatitude_grid","page":"Library","title":"RossbyWaveSpectrum.colatitude_grid","text":"colatitude_grid(m::Integer, operators)\n\nReturn the colatitude left(thetaright) grid that is used to compute eigenfunctions in real space for the specific azimuthal order m.\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.allocate_MVcache","page":"Library","title":"RossbyWaveSpectrum.allocate_MVcache","text":"allocate_MVcache(nrows)\n\nAllocate temporary matrices that are used to compute matrix products in-place. These are used in filtering the solutions (See Filters.EIGEN).\n\n\n\n\n\n","category":"function"},{"location":"API/#RossbyWaveSpectrum.allocate_BCcache","page":"Library","title":"RossbyWaveSpectrum.allocate_BCcache","text":"allocate_BCcache(nrows)\n\nAllocate temporary matrices that are used to compute matrix products in-place. These are used in filtering the solutions (See Filters.BC).\n\n\n\n\n\n","category":"function"}]
}
