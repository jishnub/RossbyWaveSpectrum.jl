<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Using the code · RossbyWaveSpectrum</title><meta name="title" content="Using the code · RossbyWaveSpectrum"/><meta property="og:title" content="Using the code · RossbyWaveSpectrum"/><meta property="twitter:title" content="Using the code · RossbyWaveSpectrum"/><meta name="description" content="Documentation for RossbyWaveSpectrum."/><meta property="og:description" content="Documentation for RossbyWaveSpectrum."/><meta property="twitter:description" content="Documentation for RossbyWaveSpectrum."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="theory/">RossbyWaveSpectrum</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="theory/">Theory</a></li><li class="is-active"><a class="tocitem" href>Using the code</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li class="toplevel"><a class="tocitem" href="#Starting-Julia"><span>Starting Julia</span></a></li><li class="toplevel"><a class="tocitem" href="#Running-the-code"><span>Running the code</span></a></li><li class="toplevel"><a class="tocitem" href="#Loading-the-results"><span>Loading the results</span></a></li><li><a class="tocitem" href="#Filtering-the-solutions-further"><span>Filtering the solutions further</span></a></li><li class="toplevel"><a class="tocitem" href="#Plotting-the-results"><span>Plotting the results</span></a></li></ul></li><li><a class="tocitem" href="API/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Using the code</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Using the code</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jishnub/RossbyWaveSpectrum.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jishnub/RossbyWaveSpectrum.jl/blob/master/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="RossbyWaveSpectrum.jl"><a class="docs-heading-anchor" href="#RossbyWaveSpectrum.jl">RossbyWaveSpectrum.jl</a><a id="RossbyWaveSpectrum.jl-1"></a><a class="docs-heading-anchor-permalink" href="#RossbyWaveSpectrum.jl" title="Permalink"></a></h1><p>A Julia code to compute the spectrum of inertial waves in the Sun.</p><h1 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h1><p>To install the code, run <code>./INSTALL.sh</code>. This requires <code>bash</code> and <code>curl</code> to run, and will download and install <code>julia</code> using the installer <code>juliaup</code>. It will also install the requisite project dependencies. The project uses Julia v1.10.0, which may be installed independently as well, in which case one only needs to instantiate the environments as listed in <code>INSTALL.sh</code>.</p><p>A part of installation process requires <code>matplotlib</code> to be available. If one is using an anaconda distribution located in their user directory, they may need to export <code>PYTHON=&lt;path to python&gt;</code> before running <code>INSTALL.sh</code>. So, for example, one may run</p><pre><code class="nohighlight hljs">PYTHON=$HOME/anaconda3/bin/python ./INSTALL.sh</code></pre><p>the first time the code is being installed (subsequent reinstallations will reuse the path that has been set). However, the code may be run without matplotlib as well, as it is only required for plotting the results.</p><p>Users running the code on a heterogeneous cluster (where the login and compute nodes have different CPU architectures) may want to set the environment variable <code>JULIA_CPU_TARGET</code> appropriately in their shell rc file. One may check the CPU architecture by running</p><pre><code class="language-julia hljs">julia&gt; Sys.CPU_NAME
&quot;skylake-avx512&quot;</code></pre><p>in the julia REPL on each node.</p><p>As an example, a valid setting may be</p><pre><code class="nohighlight hljs">export JULIA_CPU_TARGET=&quot;generic;skylake-avx512,clone_all;icelake-server,clone_all&quot;</code></pre><p>if e.g. the login node has <code>skylake-avx512</code> and the compute node has <code>icelake-server</code>. Setting this is particularly important if one node has Intel processors whereas the other has AMD ones. This should be set before running <code>INSTALL.sh</code>.</p><h1 id="Starting-Julia"><a class="docs-heading-anchor" href="#Starting-Julia">Starting Julia</a><a id="Starting-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#Starting-Julia" title="Permalink"></a></h1><p>Typically the code is run multi-threaded, so one needs to specify the number of threads while launching Julia. As an example, if we want to use <code>5</code> Julia threads, this may be done as</p><pre><code class="nohighlight hljs">julia +1.10.0 --project=. --startup-file=no -t 5</code></pre><p>The flag <code>--project</code> should point to the path to the code. The example above assumes that you are in the top-level code directory (<code>RossbyWaveSpectrum.jl</code>).</p><p>The flag <code>--startup-file=no</code> is optional, and may only be necessary if one has added a custom startup file that may interfere with the code.</p><p>The flag <code>-t 5</code> indicates that <code>5</code> Julia threads are to be used. Typically, we would want to use as many Julia threads as the number of azimuthal orders <code>m</code> that we want to solve for. This ensures that all <code>m</code>s run in parallel. Note that this differs from the number of BLAS threads that are used in solving the eigenvalue problem. If the code is being run on a cluster, this is automatically inferred from the number of allocated cores and the number of Julia threads. Alternately, this may be specified through the environment variable <code>MKL_NUM_THREADS</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Currently, the code uses multi-threading and does not support distributed usage. Therefore one instance of the code must be launched on one node of a cluster. Distinct instances of the code that use different parameters may be run parallely on multiple nodes.</p></div></div><h1 id="Running-the-code"><a class="docs-heading-anchor" href="#Running-the-code">Running the code</a><a id="Running-the-code-1"></a><a class="docs-heading-anchor-permalink" href="#Running-the-code" title="Permalink"></a></h1><p>Before running the code, we would want to set the location where the output will be written to. This is determined by the environment variable <code>SCRATCH</code>, which typically corresponds to a user&#39;s scratch directory on a cluster. The output files will be written to <code>$SCRATCH/RossbyWaves</code>, and the path will be created if it doesn&#39;t exist. Note that if <code>SCRATCH</code> is not specified, it will be set to <code>homedir()</code> by default in the code.</p><p>The first step is to load the package</p><pre><code class="language-julia hljs">using RossbyWaveSpectrum</code></pre><p>We start by computing the radial operators. We define some parameters:</p><pre><code class="language-julia hljs">nr, nℓ = 40, 20 # number of radial and latitudinal spectral coefficients
r_in_frac = 0.65 # inner boundary of the domain as a fraction of the solar radius
r_out_frac = 0.985 # outer boundary of the domain as a fraction of the solar radius
ν = 5e11 # kinematic viscosity coefficient in CGS units
trackingrate = :hanson2020 # track at 453.1 nHz; may also be a number in nHz</code></pre><p>and compute the radial operators as</p><pre><code class="language-julia hljs">operators = radial_operators(nr, nℓ; r_in_frac, r_out_frac, ν, trackingrate)</code></pre><p>Some of the common keyword arguments are demonstrated here. There are various other keyword arguments which may be passed to specify domain and model details. See <a href="API/#RossbyWaveSpectrum.radial_operators"><code>radial_operators</code></a> for details.</p><p>The second step is to obtain a function that will be used to compute the spectrum. We need to specify whether we seek equatorially symmetric or antisymmetric solutions, and the model of differential rotation that is used (see <a href="API/#RossbyWaveSpectrum.solar_differential_rotation_profile_derivatives_grid"><code>RossbyWaveSpectrum.solar_differential_rotation_profile_derivatives_grid</code></a> for details). We define some parameters</p><pre><code class="language-julia hljs">V_symmetric = true # indicates that V is symmetric about the equator, alternately set to `false` for antisymmetric
rotation_profile = :solar_latrad_squished # model of differential rotation to be used in the calculation</code></pre><p>and compute the spectrum function as</p><pre><code class="language-julia hljs">spectrumfn! = RotMatrix(Val(:spectrum), V_symmetric, rotation_profile; operators)</code></pre><p>Finally, we compute and save the spectrum for a range of azimuthal orders using the pre-defined parameters. We define</p><pre><code class="language-julia hljs">mrange = 2:6 # the range of azimuthal orders for which to compute the spectra</code></pre><p>and compute the spctrum using</p><pre><code class="language-julia hljs">save_eigenvalues(spectrumfn!, mrange; operators)</code></pre><p>This will save the results to a file named <code>&quot;solar_latrad_squished_nr40_nl20_sym.jld2&quot;</code> in the output directory given by <code>RossbyWaveSpectrum.DATADIR[]</code>. We may also specify filtering parameters as keyword arguments to <code>save_eigenvalues</code>, which will be passed on to <a href="API/#RossbyWaveSpectrum.filter_eigenvalues"><code>filter_eigenvalues</code></a>. The filtering may be performed later as well, as a post-processing step.</p><h1 id="Loading-the-results"><a class="docs-heading-anchor" href="#Loading-the-results">Loading the results</a><a id="Loading-the-results-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-the-results" title="Permalink"></a></h1><p>The results are stored in <code>jld2</code> files that are read in using the package <code>JLD2.jl</code>. We provide an interface to read these in:</p><pre><code class="language-julia hljs">julia&gt; Feig = FilteredEigen(datadir(&quot;solar_latrad_squished_nr40_nl20_sym.jld2&quot;))
Filtered eigen with m range = 2:6</code></pre><p>This will load the solutions for all <code>m</code> into a struct that may be passed directly to the plotting functions. To obtain the solutions for one <code>m</code>, we may index into <code>Feig</code> with that <code>m</code>:</p><pre><code class="language-julia hljs">julia&gt; Feig[2]
Filtered eigen with m = 2</code></pre><p>The eigenvalues and eigenvectors for this <code>m</code> may be obtained as</p><pre><code class="language-julia hljs">julia&gt; λs, vs = Feig[2];

julia&gt; λs
4-element Vector{ComplexF64}:
 0.4981592422711335 + 0.014103483029526536im
 0.6967785422145395 + 0.00046298002829591573im
  1.469490820471635 + 0.06912096500018029im
 1.6005757491199637 + 0.03673314713783im</code></pre><p>In the sign convention chosen in the code, a positive imaginary part of the eigenfrequencies indicates that the solutions are damped, and a positive real part indicates retrograde solutions. These are corrected for when plotting the solutions, so that the real part of the frequencies appear in the bottom right quadrant.</p><p>The <code>operators</code> and the parameters that were used to generate the solutions are saved in the <code>FilteredEigen</code> struct. The former is directly stored as <code>Feig.operators</code>, whereas the latter are stored in the field <code>kw</code>.</p><pre><code class="language-julia hljs">julia&gt; Feig.kw
Dict{Symbol, Any} with 3 entries:
  :V_symmetric      =&gt; true
  :filterflags      =&gt; NODES|SPATIAL_RADIAL|SPATIAL_EQUATOR|BC|EIGVEC|EIGVAL|EIGEN
  :rotation_profile =&gt; :solar_latrad_squished</code></pre><div class="admonition is-category-warn"><header class="admonition-header">Warn</header><div class="admonition-body"><p>The file format and types of contents may not be identical across releases, and backward compatibility is not always guaranteed. Please use the same version of the package that was used to create the file to read it back in.</p></div></div><h2 id="Filtering-the-solutions-further"><a class="docs-heading-anchor" href="#Filtering-the-solutions-further">Filtering the solutions further</a><a id="Filtering-the-solutions-further-1"></a><a class="docs-heading-anchor-permalink" href="#Filtering-the-solutions-further" title="Permalink"></a></h2><p>Occasionally, it might be necessary to filter the solution set further to reduce the number of modes retained in the spectrum. This may be done through the function <code>filter_eigenvalues</code>. As an example,</p><pre><code class="language-julia hljs">julia&gt; Feig_filt = filter_eigenvalues(Feig, filterflags = Filters.SPATIAL, n_cutoff = 5);</code></pre><p>For a full list of flags that may be passed to <code>filterflags</code>, check <a href="API/#RossbyWaveSpectrum.Filters"><code>Filters</code></a>. For the filter parameters that may be passed as keyword arguments, check the keys of <a href="API/#RossbyWaveSpectrum.DefaultFilterParams"><code>RossbyWaveSpectrum.DefaultFilterParams</code></a>. This also lists the default values that are used when computing the solutions.</p><h1 id="Plotting-the-results"><a class="docs-heading-anchor" href="#Plotting-the-results">Plotting the results</a><a id="Plotting-the-results-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-the-results" title="Permalink"></a></h1><p>The plotting functions are provided by the module <code>RossbyPlots</code>. This resides in a separate environment, which must be activated first using</p><pre><code class="language-julia hljs">julia&gt; import Pkg

julia&gt; Pkg.pkg&quot;activate RossbyPlots&quot;</code></pre><p>Alternately, one may press the <code>]</code> key from the julia REPL to enter the interactive <code>Pkg</code> mode, and execute</p><pre><code class="language-julia hljs">(RossbyWaveSpectrum) pkg&gt; activate RossbyPlots
  Activating project at [...]

(RossbyPlots) pkg&gt;</code></pre><p>and finally press the backspace key to get back to the REPL prompt.</p><p>The plotting functions use <code>matplotlib</code>, which must be available on the system, and accessible to <code>PyPlot</code>. The plots shown here were generated using matplotlib version 3.4.3. See the <a href="#Installation">installation</a> section on instructions to set this up if necessary.</p><p>We may plot the spectrum as</p><pre><code class="language-julia hljs">julia&gt; using RossbyPlots

julia&gt; spectrum(Feig_filt)</code></pre><p>This will produce the following plot:</p><p><img src="assets/spectrum.png" alt="spectrum"/></p><p>We find several ridges of eigenvalues.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>By default, the plot zooms into a region near the rossby ridge frequency <span>$-2(\Omega_0/2\pi)/(m+1)$</span>, so one may need to zoom out to look at eigenvalues that are not visible in this plot</p></div></div><p>We may plot one eigenvector — e.g. the <span>$12$</span>th eigenvector corresponding to <span>$m=5$</span> — as</p><pre><code class="language-julia hljs">julia&gt; eigenfunction(Feig, 5, 12)</code></pre><p>This produces the following plot:</p><p><img src="assets/eigenvector.png" alt="eigvec"/></p><p>By default, this plots the real part of <code>V</code>, but the field and component to be plotted may be specified through parameters to <code>eigenfunction</code>. Alternately, all the components of all the fields may be plotted using <code>eigenfunctions_allstreamfn</code>.</p><p>Help on the plotting functions is available in the REPL, which may be accessed through the <code>?</code> key. So e.g. <code>?spectrum</code> will display a detailed list of parameters that may be passed to <code>spectrum</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="theory/">« Theory</a><a class="docs-footer-nextpage" href="API/">Library »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Thursday 25 January 2024 06:47">Thursday 25 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
